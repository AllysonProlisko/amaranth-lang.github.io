<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Amaranth RFC Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="0001-aggregate-data-structures.html">0001-aggregate-data-structures</a></li><li class="chapter-item expanded "><a href="0003-enumeration-shapes.html">0003-enumeration-shapes</a></li><li class="chapter-item expanded "><a href="0004-const-castable-exprs.html">0004-const-castable-exprs</a></li><li class="chapter-item expanded "><a href="0005-remove-const-normalize.html">0005-remove-const-normalize</a></li><li class="chapter-item expanded "><a href="0009-const-init-shape-castable.html">0009-const-init-shape-castable</a></li><li class="chapter-item expanded "><a href="0010-move-repl-to-value.html">0010-move-repl-to-value</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Amaranth RFC Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/amaranth-lang/rfcs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="amaranth-rfcs---rfc-book"><a class="header" href="#amaranth-rfcs---rfc-book">Amaranth RFCs - <a href="https://amaranth-lang.org/rfcs/">RFC Book</a></a></h1>
<p>The &quot;RFC&quot; (request for comments) process is intended to provide a consistent and controlled path for changes to Amaranth (such as new features) so that all stakeholders can be confident about the direction of the project.</p>
<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p>
<p>Some changes though are &quot;substantial&quot;, and we ask that these be put through a bit of a design process and produce a consensus among the Amaranth community.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="introduction.html#amaranth-rfcs">Opening</a></li>
<li><a href="introduction.html#table-of-contents">Table of Contents</a></li>
<li><a href="introduction.html#when-you-need-to-follow-this-process">When you need to follow this process</a></li>
<li><a href="introduction.html#before-creating-an-rfc">Before creating an RFC</a></li>
<li><a href="introduction.html#what-the-process-is">What the process is</a></li>
<li><a href="introduction.html#the-rfc-life-cycle">The RFC life-cycle</a></li>
<li><a href="introduction.html#reviewing-rfcs">Reviewing RFCs</a></li>
<li><a href="introduction.html#implementing-an-rfc">Implementing an RFC</a></li>
<li><a href="introduction.html#acknowledgements">Acknowledgements</a></li>
<li><a href="introduction.html#license">License</a></li>
</ul>
<h2 id="when-you-need-to-follow-this-process"><a class="header" href="#when-you-need-to-follow-this-process">When you need to follow this process</a></h2>
<p>You need to follow this process if you intend to make &quot;substantial&quot; changes to <a href="https://github.com/amaranth-lang/amaranth">core Amaranth language</a>. In the future you will need to follow this process for the <a href="https://github.com/amaranth-lang/amaranth-stdio">standard I/O library</a> and the <a href="https://github.com/amaranth-lang/amaranth-soc">System-on-Chip library</a> as well, but at the moment they are not covered.</p>
<p>What constitutes a &quot;substantial&quot; change is evolving based on community norms and varies depending on what part of the ecosystem you are proposing to change, but may include the following:</p>
<ul>
<li>Any semantic or syntactic change to the language (<code>amaranth.hdl</code>) that is not a bugfix.</li>
<li>Behavioral changes to the standard library (<code>amaranth.lib</code>).</li>
<li>Behavioral changes to the toolchain interface (<code>amaranth.vendor</code>).</li>
</ul>
<p>Some changes do not require an RFC:</p>
<ul>
<li>Rephrasing, reorganizing, refactoring, or otherwise &quot;changing shape does not change meaning&quot;.</li>
<li>Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, handling more errors, etc.)</li>
</ul>
<p>If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first. When in doubt, please open an issue to discuss the feature first and one of the core maintainers will say if the change requires an RFC or not.</p>
<h2 id="before-creating-an-rfc"><a class="header" href="#before-creating-an-rfc">Before creating an RFC</a></h2>
<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother.</p>
<p>Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project developers beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p>
<p>The most common preparations for writing and submitting an RFC include talking the idea over on our IRC channel, <a href="https://web.libera.chat/#amaranth-lang">#amaranth-lang at libera.chat</a>, or opening an issue on the corresponding repository to gather feedback.</p>
<h2 id="what-the-process-is"><a class="header" href="#what-the-process-is">What the process is</a></h2>
<p>In short, to get a major feature added to Amaranth, one must first get the RFC merged into the RFC repository as a markdown file. At that point the RFC is &quot;active&quot; and may be implemented with the goal of eventual inclusion into Amaranth.</p>
<ul>
<li>Fork the RFC repository.</li>
<li>Copy 0000-template.md to text/0000-my-feature.md (where &quot;my-feature&quot; is descriptive). Don't assign an RFC number yet; This is going to be the PR number and we'll rename the file accordingly if the RFC is accepted.</li>
<li>Fill in the RFC. Put care into the details: RFCs that do not present convincing motivation, demonstrate lack of understanding of the design's impact, or are disingenuous about the drawbacks or alternatives tend to be poorly-received.</li>
<li>Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response.</li>
<li>Now that your RFC has an open pull request, use the issue number of the PR to update your 0000- prefix to that number.</li>
<li>Build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. Feel free to reach out to the RFC assignee in particular to get help identifying stakeholders and obstacles.</li>
<li>RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. You can make edits, big and small, to the RFC to clarify or change the design, but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li>
<li>At some point, a core maintainer will make a decision on the disposition for the RFC (merge or close).
<ul>
<li>This step is taken when enough of the tradeoffs have been discussed that the core maintainer is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position.</li>
</ul>
</li>
</ul>
<h2 id="the-rfc-life-cycle"><a class="header" href="#the-rfc-life-cycle">The RFC life-cycle</a></h2>
<p>Once an RFC becomes &quot;active&quot; then authors may implement it and submit the feature as a pull request to the corresponding repository. Being &quot;active&quot; is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it.</p>
<p>Furthermore, the fact that a given RFC has been accepted and is &quot;active&quot; implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature. While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project developers will take on responsibility for implementing their accepted feature.</p>
<p>Modifications to &quot;active&quot; RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of the process means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of the next major release.</p>
<p>In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a &quot;very minor change&quot; is up to the core maintainers to decide.</p>
<h2 id="reviewing-rfcs"><a class="header" href="#reviewing-rfcs">Reviewing RFCs</a></h2>
<p>While the RFC pull request is up, the core maintainers may schedule meetings with the author and/or relevant stakeholders to discuss the issues in greater detail, and the topic may be discussed at weekly meetings. In either case a summary from the meeting will be posted back to the RFC pull request.</p>
<p>A core maintainer makes final decisions about RFCs after the benefits and drawbacks are well understood. These decisions can be made at any time, but the core maintainer will regularly issue decisions. When a decision is made, the RFC pull request will either be merged or closed. In either case, if the reasoning is not clear from the discussion in thread, the core maintainer will add a comment describing the rationale for the decision.</p>
<h2 id="implementing-an-rfc"><a class="header" href="#implementing-an-rfc">Implementing an RFC</a></h2>
<p>Some accepted RFCs represent vital features that need to be implemented right away. Other accepted RFCs can represent features that can wait until some arbitrary developer feels like doing the work. Every accepted RFC has an associated issue tracking its implementation in the corresponding repository.</p>
<p>The author of an RFC is not obligated to implement it. Of course, the RFC author (like any other developer) is welcome to post an implementation for review after the RFC has been accepted.</p>
<p>If you are interested in working on the implementation for an &quot;active&quot; RFC, but cannot determine if someone else is already working on it, feel free to ask (e.g. by leaving a comment on the associated issue).</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>The process described in this document is based on the <a href="https://github.com/rust-lang/rfcs">Rust RFC process</a>. It has been simplified to match the needs of the much smaller Amaranth community; in particular, policy (including the RFC process itself) is not currently defined through the RFC process.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This repository is licensed under the <a href="LICENSE.txt">MIT license</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-14</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/1">amaranth-lang/rfcs#1</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/748">amaranth-lang/amaranth#748</a></li>
</ul>
<h1 id="aggregate-data-structure-library"><a class="header" href="#aggregate-data-structure-library">Aggregate data structure library</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Add a rich set of standard library classes for accessing hierarchical aggregate data an idiomatic way, to fill one of the two major use cases of <code>Record</code> while avoiding its downsides.</p>
<p>See also #???.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Amaranth has a single data storage primitive: <code>Signal</code>. A <code>Signal</code> can be referenced on the left hand and the right hand side of an assignment, and so can be its slices. Although a signal serves the role of a numeric and bit container type fine, designs often include signals used as bit containers whose individual bits are named and have unique meanings. A mechanism that allows referring to such bit fields by name is essential.</p>
<p>Currently, the role of this mechanism is served by <code>Record</code>. However, <code>Record</code> has multiple major drawbacks:</p>
<ol>
<li>
<p><code>Record</code> attempts to do too much: it is both a mechanism for <em>controlling representation</em> (including implicitly casting a record to a value) and a mechanism for <em>defining interfaces</em> (specifying signal directions and facilitating connections between records).</p>
<p>These mechanisms should be defined separately, since the only aspect they have in common is using a container class that consists of multiple named fields. Conflating the two mechanisms constraints the design space, making addressing the other drawbacks impossible, and the ill-defined scope encourages bugs in downstream code.</p>
</li>
<li>
<p><code>Record</code> has limited composability: records can only be nested within each other. Practical designs (in particular, implementations of protocols) use data with complex representation beyond nested sequences of fields: these include overlaid sequences of fields (where interpretation alternates based on some discriminant) and arrays of fields (where a field can be indexed by a non-constant), where any individual field can have a complex representation itself.</p>
<p><code>Record</code> is structured as a sequence of <code>Signal</code>s, which is a part of its API. As such, it cannot support overlaid fields, and implementing support for arrays of fields is challenging.</p>
</li>
<li>
<p><code>Record</code> has limited introspectability: while its <code>layout</code> member can be accessed to enumerate its fields, the results do not include field boundaries, and the types of the returned shape-castable objects are preserved only as an implementation detail. <code>Layout</code> objects themselves are also not shape-castable.</p>
<p><code>Record</code> and <code>Layout</code> are structured as a sequence of <code>Signal</code>s rather than a view into an underlying bit container, which is reflected in its API. Thus, <code>Layout</code> does not fit into Amaranth's data model, which concerns individual values.</p>
</li>
<li>
<p><code>Record</code> comes with its own storage: while its <code>fields</code> argument can be used to substitute the signals that individual fields are pointing to (in an awkward and error-prone way), it is still a collection of <code>Signal</code>s. Using <code>Record</code> to impose structure on an existing <code>Value</code> requires a <code>Module</code> and a combinatorial assignment. This is an unnecessary complication, especially in helper functions.</p>
</li>
<li>
<p><code>Record</code> does not play well with Python's type annotations. Amaranth developers often inherit from <code>Record</code> as well as <code>Layout</code>, but in both cases the class definition syntax is usually little more than a way to define a callable returning a <code>Record</code> with a specific layout, and provides no benefits for IDE users.</p>
</li>
<li>
<p><code>Record</code> reserves a lot of names, including commonly used names like <code>connect</code>, <code>any</code>, <code>all</code>, and <code>matches</code>. Conversely, it defines a lot of arithmetic methods that are rarely if ever used on field containers.</p>
</li>
<li>
<p><code>Layout</code>'s DSL is very amorphous. It passes around variable length tuples. The second element of these tuples (the shape) can be another <code>Layout</code>, which is neither a shape nor a shape-castable object.</p>
</li>
<li>
<p>Neither <code>Record</code> nor <code>Layout</code> allow defining fields whose shapes are arbitrary <code>ShapeCastable</code> classes.</p>
</li>
</ol>
<p>Since these drawbacks are entrenched in the public API and heavily restrict usefulness of <code>Record</code> as a mechanism for specifying data representation, a new mechanism must replace it.</p>
<h2 id="overview-and-examples"><a class="header" href="#overview-and-examples">Overview and examples</a></h2>
<p>This section shows a bird's eye view of the new syntax and behavior proposed in this RFC. The detailed design is described afterwards.</p>
<pre><code class="language-python">from amaranth import *
from amaranth.lib import data


# Declaring a simple structure:
class Float32(data.Struct):
    fraction: unsigned(23)
    exponent: unsigned(8)
    sign: unsigned(1)


# Defining a signal with the structure above:
flt_a = Float32()

# Reinterpreting an existing value with the same structure:
flt_b = Float32(Const(0b00111110001000000000000000000000, 32))

# Referencing and updating structure fields by name:
with m.If(flt_b.fraction &gt; 0):
    m.d.comb += [
        flt_a.sign.eq(1),
        flt_a.exponent.eq(127)
    ]


# Declaring a simple union, referencing an existing structure:
class FloatOrInt32(data.Union):
    float: Float32
    int: signed(32)


# Using the union to bitcast an IEEE754 value from an integer:
f_or_i = FloatOrInt32()
is_sub_1 = Signal()
m.d.comb += [
    f_or_i.int.eq(0x41C80000),
    is_sub_1.eq(f_or_i.float.exponent &lt; 127) # =&gt; 1
]


class Op(enum.Enum):
  ADD = 0
  SUB = 1


# Programmatically declaring a structure layout:
adder_op_layout = data.StructLayout({
    &quot;op&quot;: Op,
    &quot;a&quot;: Float32,
    &quot;b&quot;: Float32
})

# Using the layout defined above to define appropriately sized storage...
adder_op_storage = Signal(adder_op_layout)
len(adder_op_storage) # =&gt; 65

# ... and wrap it for the fields to be accessible.
adder_op = data.View(adder_op_layout, adder_op_storage)
m.d.comb += [
    adder_op.op.eq(Op.SUB),
    adder_op.a.eq(flt_a),
    adder_op.b.eq(flt_b)
]
</code></pre>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed design</a></h2>
<p>This RFC proposes a number of language and library additions:</p>
<ul>
<li>Adding a <code>ShapeCastable</code> interface, similar to <code>ValueCastable</code>;</li>
<li>Adding classes that hierarchically describe representation of aggregate values: named field containers with non-overlapping fields (structs), named field containers with overlapping fields (unions), and indexed field containers (arrays);</li>
<li>Adding a wrapper class that accepts a <code>Value</code> (or a <code>ValueCastable</code> object) and provides accessors that slice it according to the corresponding aggregate representation;</li>
<li>Adding an ergonomic and IDE-compatible interface for building descriptions of non-parametric layouts of aggregate values.</li>
</ul>
<h3 id="user-defined-shape-castable-objects"><a class="header" href="#user-defined-shape-castable-objects">User-defined shape-castable objects</a></h3>
<p><code>ShapeCastable</code> is an interface for defining <code>Shape</code>-like values outside of the core Amaranth language. It is functionally identical to <code>ValueCastable</code>, and could be used like:</p>
<pre><code class="language-python">from amaranth import *


class Layout(ShapeCastable):
    def __init__(self, fields):
        self.fields = fields

    def as_shape(self):
        return unsigned(sum(len(field) for field in self.fields))
</code></pre>
<h3 id="value-layout-descriptions"><a class="header" href="#value-layout-descriptions">Value layout descriptions</a></h3>
<p>Aggregate value layouts are represented using two classes: <code>amaranth.lib.data.Field</code> and <code>amaranth.lib.data.Layout</code>:</p>
<ul>
<li>A <code>Field(shape_castable, offset=0)</code> object describes a field of the given shape starting at bit number <code>offset</code> of the aggregate value.</li>
<li>A <code>Layout()</code> object describes an abstract aggregate value. It can be iterated, returning <code>(name, field)</code> or <code>(index, field)</code> pairs; or indexed (<code>__getitem__</code>) by the name or index of the field. It has a <code>.size</code> in bits, determined by the type of the layout, and is shape-castable, being converted to <code>unsigned(layout.size())</code>.
<ul>
<li>A <code>StructLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with non-overlapping named fields (struct). The fields are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>UnionLayout(members={&quot;name&quot;: shape_castable})</code> object describes an aggregate value with overlapping named fields (union). The fields are placed at offset 0.</li>
<li>An <code>ArrayLayout(element=shape_castable, length=1)</code> object describes an aggregate value with indexed fields (array). The fields all have identical shape and are placed at offsets such that they immediately follow one another, from least significant to most significant.</li>
<li>A <code>FlexibleLayout(fields={&quot;name&quot;: field, 0: field}, size=16)</code> object describes a aggregate value with fields arbitrarily placed within its bounds.</li>
</ul>
</li>
</ul>
<p>The representation of a discriminated union could be programmatically constructed as follows:</p>
<pre><code class="language-python">import enum
from amaranth.lib import data


class Kind(enum.Enum):
    ONE_SIGNED = 0
    TWO_UNSIGNED = 1


layout = data.StructLayout({
    &quot;kind&quot;: Kind,
    &quot;value&quot;: data.UnionLayout({
        &quot;one_signed&quot;: signed(2),
        &quot;two_unsigned&quot;: data.ArrayLayout(unsigned(1), 2)
    })
})
</code></pre>
<h3 id="aggregate-value-access"><a class="header" href="#aggregate-value-access">Aggregate value access</a></h3>
<p>Aggregate values are manipulated through the <code>amaranth.lib.data.View</code> class. A <code>View(layout, value_castable)</code> object wraps a value-castable object (which may be a valid assignment target) and provides access to fields according to the layout. A view is itself value-castable, being converted to the object it's wrapping. If the view is wrapping a valid assignment target, then the accessors also return a valid assignment target.</p>
<p>Fields can be accessed using either <code>__getitem__</code> (for both named and indexed fields) or <code>__getattr__</code> (for named fields). To avoid name collisions when using <code>__getattr__</code> to access fields, views do not define any non-reserved attributes of their own except for the <code>.as_value()</code> casting method. Field names starting with <code>_</code> are reserved as attribute names and and can only be accessed using the <code>view[&quot;name&quot;]</code> indexing syntax.</p>
<p>When a view is used to access a field whose shape is an ordinary <code>Shape</code> object, the accessor returns a <code>Value</code> of the corresponding shape that slices the viewed object.</p>
<p>When a view is used to access a field whose shape is an aggregate value layout, the accessor returns another <code>View</code> with this layout, wrapping the slice of the viewed object. For fields that have any other shape-castable object set as their shape, the behavior is the same as for the <code>Shape</code> case.</p>
<p>Views that have an <code>ArrayLayout</code> as their layout can be indexed with a <code>Value</code>. In this case, the viewed object is sliced with <code>Value.word_select</code>.</p>
<p>A signal can be manipulated with its structure viewed as the discriminated union defined above as follows:</p>
<pre><code class="language-python"># creates an unsigned(3) signal by shape-casting `layout`
sig = Signal(layout)
view = data.View(layout, sig)

# if the second argument is omitted, a signal with the right shape is created internally;
# the line below is equivlent to the two lines above
view = data.View(layout)

m = Module()
m.d.comb += [
    view.kind.eq(Kind.TWO_UNSIGNED),
    view.value.two_unsigned[0].eq(1),
]
</code></pre>
<h3 id="ergonomic-layout-definition"><a class="header" href="#ergonomic-layout-definition">Ergonomic layout definition</a></h3>
<p>Rather than using the underlying <code>StructLayout</code> and <code>UnionLayout</code> classes, struct and union layouts can be defined using the Python class definition syntax, with the shapes of the members specified using the <a href="https://peps.python.org/pep-0526/">PEP 526</a> variable annotations:</p>
<pre><code class="language-python">class SomeVariant(data.Struct):
    class Value(data.Union):
        one_signed: signed(2)
        two_unsigned: data.ArrayLayout(unsigned(1), 2)

    kind: Kind
    value: Value


# this class can be used in the same way as a `data.View` without needing to specify the layout:
view2 = SomeVariant()
m.d.comb += [
    view2.kind.eq(Kind.ONE_SIGNED),
    view2.value.eq(view.value)
]
</code></pre>
<p>When they refer to other structures or unions defined in the same way, the variable annotations are also valid <a href="https://peps.python.org/pep-0484/">PEP 484</a> type hints, and will be used by IDEs to derive types of properties and expressions. Otherwise, the annotations will be opaque to IDEs or type checkers, but are still useful for a human reader.</p>
<p>The classes defined in this way are shape-castable and can be used anywhere a shape or a aggregate value layout is accepted:</p>
<pre><code class="language-python">sig2 = Signal(SomeVariant)
layout2 = data.StructLayout({
    &quot;ready&quot;: unsigned(1),
    &quot;payload&quot;: SomeVariant
})
</code></pre>
<p><strong>Implementation note:</strong> This can be achieved by using a custom metaclass for <code>Struct</code> and <code>Union</code> that inherits from <code>ShapeCastable</code>.</p>
<p>If an explicit <code>Layout</code> object is nevertheless needed (e.g. for introspection), it can be extracted from the class using <code>Layout.cast</code>:</p>
<pre><code class="language-python">layout == data.Layout.cast(SomeVariant) # =&gt; True
</code></pre>
<p>Conversely, the shape-castable object defining the layout of a <code>View</code> (which might be a <code>Layout</code> subclass or a <code>Struct</code>/<code>Union</code> subclass) can be extracted from the view using <code>Layout.of</code>:</p>
<pre><code class="language-python">SomeVariant is data.Layout.of(view2) # =&gt; True
</code></pre>
<h3 id="advanced-usage-parametric-layouts"><a class="header" href="#advanced-usage-parametric-layouts">Advanced usage: Parametric layouts</a></h3>
<p>The ergonomic definitions using the <code>Struct</code> and <code>Union</code> base classes are concise and integrated with Python type annotations. However, they cannot be used if the layout of an aggregate value is parameterized. In this case, a class with similar functionality can be defined in a more explicit way:</p>
<pre><code class="language-python">class Stream8b10b(data.View):
    data: Signal
    ctrl: Signal

    def __init__(self, value=None, *, width: int):
        super().__init__(data.StructLayout({
            &quot;data&quot;: unsigned(8 * width),
            &quot;ctrl&quot;: unsigned(width)
        }), value)


len(Stream8b10b(width=1).data) # =&gt; 8
len(Stream8b10b(width=4).data) # =&gt; 32
</code></pre>
<p>Since the parametric class name itself does not have a fixed layout, it cannot be used with <code>Layout.cast</code>. Similarly, the type annotations cannot include specific field widths; they are included only to indicate the presence of a corresponding attribute to IDEs and type checkers.</p>
<h3 id="structure-field-ordering"><a class="header" href="#structure-field-ordering">Structure field ordering</a></h3>
<p>The fields of a structure layout object are ordered from least significant to most significant:</p>
<pre><code class="language-python">float32_layout = data.StructLayout({
    &quot;fraction&quot;: unsigned(23),   # bits  0..22
    &quot;exponent&quot;: unsigned(8),    # bits 23..30
    &quot;sign&quot;: unsigned(1)         # bit  31
})

class Float32(data.Struct):
    fraction: unsigned(23)      # bits  0..22
    exponent: unsigned(8)       # bits 23..30
    sign: unsigned(1)           # bit  31
</code></pre>
<p>In other words, the following identity holds:</p>
<pre><code class="language-python">float32_storage = Signal(float32_layout)
float32 = data.View(float32_layout, float32_storage)

float32_storage == Cat(float32.fraction, float32_layout.exponent, float32.sign)
</code></pre>
<h3 id="customizing-the-automatically-created-signal"><a class="header" href="#customizing-the-automatically-created-signal">Customizing the automatically created <code>Signal</code></a></h3>
<p>When a view is instantiated without an explicit view target, it creates a <code>Signal</code> with a shape matching the view layout. The <code>View</code> constructor accepts all of the <code>Signal</code> constructor keyword arguments and passes them along; the <code>reset=</code> argument accepts a struct or an array (according to the type of the layout):</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})

flt_reset_less = Float32(reset_less=True)
</code></pre>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<p>This feature introduces a language-level concept, shape-castable objects, increasing language complexity.</p>
<p>This feature introduces a finely grained hierarchy of 5 similar and related classes for describing layouts.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>Do nothing. <code>Record</code> will continue to be used alongside the continued proliferation of ad-hoc implementations of similar functionality.</p>
<p>Remove <code>ArrayLayout</code> from this proposal. The array functionality is niche and introduces the complexity of handling by-index accessors alongside by-name ones.</p>
<p>Remove <code>ArrayLayout</code>, <code>UnionLayout</code>, and <code>FlexibleLayout</code> from this proposal. Their functionality is less commonly used than that of <code>StructLayout</code> and introduces the substantial complexity of handling fields at arbitrary offsets. (This would make <code>amaranth.lib.data</code> useless for slicing CSRs in Amaranth SoC.) This change would bring this proposal close to the original <code>PackedStruct</code> proposal discussed in https://github.com/amaranth-lang/amaranth/issues/342.</p>
<p>Combine the <code>Layout</code> and all of its derivative classes into a single <code>Layout(fields={&quot;name&quot;: Field(...), 0: Field(...)})</code> class that provides a superset of the functionality. This simplifies the API, but makes introspection of aggregate layouts very difficult and can be inefficient if large arrays are used. In this case, factory methods of the <code>Layout</code> class would be provided for more convenient construction of regular struct, union, and array layouts.</p>
<p>Remove <code>Struct</code> and <code>Union</code> annotation-driven definition syntax. This makes the API simpler, less redundant, and with fewer corner cases, also avoiding the use of variable annotations that are not valid PEP 484 type hints, at the cost of a continued jarring experience for IDE users.</p>
<p>Include a more concise and less visually noisy way to build <code>StructLayout</code> and <code>UnionLayout</code> objects (or their equivalents) using a builder pattern. This may make the syntax slightly nicer, though the RFC author could not come up with anything that would actually be such.</p>
<h2 id="bikeshedding"><a class="header" href="#bikeshedding">Bikeshedding</a></h2>
<p>The names of the <code>Field</code>, <code>*Layout</code>, and <code>View</code> classes could be changed to something better.</p>
<ul>
<li><code>IrregularLayout</code> was renamed to <code>FlexibleLayout</code>.</li>
</ul>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p>This feature could be improved in several ways that are not in scope of this RFC:</p>
<ul>
<li><code>StructLayout</code>, <code>UnionLayout</code>, and <code>ArrayLayout</code> could be extended to generate layouts with padding at the end (for structs and unions) or between elements (for arrays). Currently this requires the use of a <code>FlexibleLayout</code>.</li>
<li><code>StructLayout</code> could be extended to accept a list of fields in addition to a map of field names to values. In this case, it would represent an aggregate value with non-overlapping indexed fields (tuple).</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_1&quot;</code>, <code>&quot;_2&quot;</code>, ...) as designating padding bits. In this case, the offset of the following fields would be adjusted, and the fields with such names would not appear in the layout.</li>
<li><code>Struct</code> and/or <code>StructLayout</code> could be extended to treat certain reserved field names (e.g. <code>&quot;_&quot;</code> for <code>Struct</code> and <code>None</code> for <code>StructLayout</code>) as designating an anonymous inner aggregate. In this case, the members of the anonymous inner aggregate would be possible to access as if they were the members of the outer aggregate.</li>
<li>The automatic wrapping of accessed aggregate fields done by <code>View</code> could be extended to call a user-specified cast function rather than hard-coding a check for whether the shape is a <code>Layout</code>. This would allow seamless inclusion of user-defined value-castable types in aggregates.</li>
<li>The <a href="https://peps.python.org/pep-0484/">PEP 484</a> generics could be used to define layouts parametric over field shapes, using type annotations alone. Since Python does not have type-level integers, layouts parametric over field sizes would still need to be defined explicitly.</li>
<li>The struct, union, and enum support could be used as the building blocks to implement first-class discriminated unions. Discriminated unions will also benefit from tuples, described above. (<a href="https://github.com/amaranth-lang/amaranth/issues/693#issuecomment-1089322514">Suggestion</a> by @lachlansneff.)</li>
</ul>
<h2 id="acknowledgements-1"><a class="header" href="#acknowledgements-1">Acknowledgements</a></h2>
<p><a href="https://github.com/modwizcode">@modwizcode</a>, <a href="https://github.com/Kaucasus">@Kaucasus</a>, and <a href="https://github.com/lachlansneff">@lachlansneff</a> provided valuable feedback while this RFC was being drafted.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-27</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/3">amaranth-lang/rfcs#3</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/756">amaranth-lang/amaranth#756</a></li>
</ul>
<h1 id="enumeration-shapes"><a class="header" href="#enumeration-shapes">Enumeration shapes</a></h1>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Allow explicitly specifying shape for enumerations as an alternative to implicitly inferring it.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>Hardware development includes a lot of enumerated values, so first class support for enumerations is important, and so is integration with the standard Python mechanisms for specifying enumerations.</p>
<p>Amaranth accepts <code>enum.Enum</code> subclasses anywhere a shape is expected, and <code>enum.Enum</code> instances anywhere a value is expected:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth import *
&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Kind(Enum):
...     MUL = 0
...     ADD = 1
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(2)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 2'd2)
</code></pre>
<p>However, this does not cover an important use case: a enumeration where many values are reserved. For example, if the <code>Kind</code> enumeration above may need to be extended in the future, it would be necessary to reserve space for additional values, which may require additional storage bits. Right now there is no way to specify that <code>Kind</code> should be cast to e.g. <code>unsigned(4)</code>.</p>
<h2 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code> can be used as a drop-in replacement for the Python standard library <code>enum</code> module. It exports the same classes as the ones provided by Python's <code>enum</code> (namely <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code>) and provides the same functionality, adding the possibility of specifying a shape for the enumeration when it is defined:</p>
<pre><code class="language-python">&gt;&gt;&gt; from amaranth.lib.enum import Enum
&gt;&gt;&gt; class Kind(Enum, shape=unsigned(4)):
...    MUL = 0
...    ADD = 1
...    SUB = 2
...
&gt;&gt;&gt; Shape.cast(Kind)
unsigned(4)
&gt;&gt;&gt; Value.cast(Kind.SUB)
(const 4'd2)
</code></pre>
<p>If the <code>shape=</code> keyword argument is not specified, the enumeration is treated exactly the same as the corresponding standard Python class.</p>
<p>If the values specified for the members are not representable with the explicitly provided shape, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = 8
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: 8&gt; will be truncated to enumeration shape unsigned(3)
&gt;&gt;&gt; class Funct3(Enum, shape=unsigned(3)):
...     SUB = -1
...
&lt;stdin&gt;:1: RuntimeWarning: Value of enumeration member &lt;Funct3.SUB: -1&gt; is signed, but enumeration shape is unsigned(3)
</code></pre>
<p>A shape that is specified for a base class will be inherited in subclasses:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Enum3(Enum, shape=unsigned(3)): pass
...
&gt;&gt;&gt; class Funct3(Enum3):
...     SUB = 2
...
&gt;&gt;&gt; Shape.cast(Funct3)
unsigned(3)
</code></pre>
<p>If a enumeration without an explicitly defined shape is used in a concatenation, a warning is emitted:</p>
<pre><code class="language-python">&gt;&gt;&gt; class Kind(Enum):
...     ADD = 1
...
&gt;&gt;&gt; Cat(Kind.ADD)
&lt;stdin&gt;:1: SyntaxWarning: Argument #1 of Cat() is an enumeration Kind.ADD without a defined shape used in bit vector context; define the enumeration by inheriting from the class in amaranth.lib.enum and specifying the 'shape=' keyword argument
(cat (const 1'd1))
</code></pre>
<h2 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h2>
<p>The Amaranth standard library module, <code>amaranth.lib.enum</code>, exports all of the public names of the Python standard library <code>enum</code> module. The <code>EnumMeta</code> class adds the functionality for storing and casting to shapes, and inherits from <code>ShapeCastable</code>. The <code>Enum</code>, <code>Flag</code>, <code>IntEnum</code>, and <code>IntFlag</code> classes in this module derive from <code>enum.Enum</code>, <code>enum.Flag</code>, <code>enum.IntEnum</code>, and <code>enum.IntFlag</code> respectively, and use <code>amaranth.lib.enum.EnumMeta</code> as their metaclass, which makes subclasses of <code>amaranth.lib.enum.Enum</code>, etc be instances of <code>ShapeCastable</code>.</p>
<p>When a new <code>amaranth.lib.enum.Enum</code> subclass is defined, <code>amaranth.lib.enum.EnumMeta.__new__</code> checks that the enumeration members are valid (currently, Amaranth requires these to be integers), and if the <code>shape=</code> argument is provided, stores it in an internal attribute. Importantly, the attribute is only set if the argument is provided, making it possible to distinguish these cases later. It also checks that all of the members can be represented by the given shape.</p>
<p>When an <code>amaranth.lib.enum.Enum</code> subclass is cast to a shape, if the internal attribute is set, the shape in it is returned. Otherwise it is cast to a shape using exactly the same logic as what <code>Shape.cast</code> uses for <code>enum.Enum</code> subclasses.</p>
<p>When an instance of a <code>enum.Enum</code> subclass is used in a concatenation, and it is not an instance of <code>ShapeCastable</code>, or if it lacks the <code>_amaranth_shape_</code> attribute, a warning is emitted. This approach avoids a circular dependency between <code>amaranth.hdl.ast</code> and <code>amaranth.lib.enum</code>.</p>
<h2 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h2>
<ul>
<li>Introducing a new standard library module increases the API surface.</li>
<li>The names of enumeration base classes are the same as the standard library enumeration base classes, which may be confusing.</li>
<li>Deriving from a different class requires changes to the enumeration at its point of definition, meaning that it is not possible to annotate a enum that comes from an external library with an Amaranth shape.</li>
</ul>
<h2 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h2>
<p>Ultimately, this feature boils down to defining an internal variable on an enum, which is then used by <code>Shape.cast</code> and other core Amaranth code. There are a few possible options for doing this.</p>
<ol>
<li>
<p>Special class variable:</p>
<pre><code class="language-python">class SomeEnum(enum.Enum):
    _amaranth_shape_ = unsigned(4)
</code></pre>
</li>
<li>
<p>Class decorator:</p>
<pre><code class="language-python">@amaranth.shape(unsigned(4))
class SomeEnum(enum.Enum):
</code></pre>
</li>
<li>
<p>Class keyword argument (this proposal):</p>
<pre><code class="language-python">class SomeEnum(amaranth.lib.enum.Enum, shape=unsigned(4)):
</code></pre>
</li>
</ol>
<p>Alternative (1) has the following drawbacks:</p>
<ul>
<li>It is not possible to check that the enumeration members can be represented by the specified shape at the point of definition.</li>
<li>It exposes what should be an implementation detail to the user.</li>
<li>The documentation for the standard <code>enum</code> module does not specify whether it's OK to use <code>_sunder_</code> names for one's own purposes, but it would have to be a part of the stable API.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>No additional methods or classes in the API surface.</li>
<li><code>_amaranth_shape_</code> makes it immediately clear what's going on.</li>
<li>The variable can be defined on any enum, even an external one.</li>
</ul>
<p>Alternative (2) has the following drawbacks:</p>
<ul>
<li>It's not clear where the <code>shape</code> decorator should be. It can only be applied to enums, but there's no enum-specific namespace in Amaranth core to put it into.</li>
<li><code>SomeEnum</code> would inherit from the standard <code>Enum</code> class and therefore <code>isinstance(SomeEnum, ShapeCastable)</code> would be <code>False</code> unless <code>ShapeCastable.__instancecheck__</code> is overridden to fix that.</li>
</ul>
<p>Its advantages are:</p>
<ul>
<li>The decorator can be applied to an external enum.</li>
</ul>
<p>Alternative (3) has the drawbacks specified above, and the following advantages:</p>
<ul>
<li><code>isinstance(SomeEnum, ShapeCastable)</code> naturally works.</li>
<li>As a consequence, no additional code is required in the core language. All of the functionality necessary for the feature to work lives in <code>amaranth.lib.enum</code>.</li>
<li>The <code>shape</code> argument matches <code>Signal(shape=)</code> (even though no one uses the keyword form) and works the way one would naturally expect.</li>
<li>Uses of <code>import enum</code> can be transparently replaced with <code>from amaranth.lib import enum</code> without updating the call sites, making the migration as easy as the other alternatives.</li>
</ul>
<h2 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/4">amaranth-lang/rfcs#4</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/755">amaranth-lang/amaranth#755</a></li>
</ul>
<h1 id="const-castable-expressions"><a class="header" href="#const-castable-expressions">Const-castable expressions</a></h1>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Define a subset of expressions that are &quot;const-castable&quot; and accept them in contexts where currently only integers and enumerations with integer values are accepted.</p>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>In certain contexts, Amaranth requires a constant to be used. These contexts are: <code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member that is being cast to a value.</p>
<p>Currently, only integers and enumeration members with integer values are considered constants. However, this is too limiting. For example, when developing a CPU, one might want to define control signals for several functional units and combine them into instructions, or conversely, match an instruction against a combination of control signals:</p>
<pre><code class="language-python">class Func(Enum):
    ADD = 0
    SUB = 1

class Src(Enum):
    MEM = 0
    REG = 1

class Instr(Enum):
    ADD  = Cat(Func.ADD, Src.MEM)
    ADDI = Cat(Func.ADD, Src.REG)
    ...

with m.Switch(instr):
    with m.Case(Cat(Func.ADD, Src.MEM)):
        ...
</code></pre>
<p>Currently, all of these cases would produce syntax errors.</p>
<p>There is a private <code>Value._as_const</code> method. It is not used internally, however Amaranth developers have started using it due to unmet needs. Removing it without providing a replacement would be disruptive, and will result in downstream codebases defining their own equivalent.</p>
<h2 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h2>
<p>In any context where a constant is accepted (<code>with m.Case(...):</code>, <code>Value.matches(...)</code>, and the value of an enumeration member), a &quot;const-castable&quot; expression can be used. The following expressions are const-castable:</p>
<ul>
<li><code>int</code>;</li>
<li><code>Const</code>;</li>
<li><code>Cat</code> where all operands are const-castable;</li>
<li>instance of a <code>Enum</code> subclass where the value is const-castable.</li>
</ul>
<p>A const-castable expression can be converted to a <code>Const</code> using <code>Const.cast</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; Const.cast(1)
(const 1'd1)
&gt;&gt;&gt; Const.cast(Cat(1, 0, 1))
(const 3'd5)
&gt;&gt;&gt; Const.cast(Cat(Func.ADD, Src.REG))
(const 2'd2)
</code></pre>
<h2 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h2>
<p>The <code>Const.cast</code> static method casts its argument to a value and examines it. If it is a <code>Const</code>, it is returned. If it is a const-castable expression, the operands are recursively cast to constants, and the expression is evaluated.</p>
<p>The list of const-castable expressions is:</p>
<ul>
<li><code>Cat</code></li>
</ul>
<p>The <code>m.Case(...)</code> (through the <code>Switch()</code> constructor) and <code>Value.matches(...)</code> methods accept two kinds of operands: const-castable expressions, or a string containing a bit pattern (a sequence of <code>0</code>, <code>1</code>, or <code>-</code> meaning a wildcard).</p>
<p>The <code>Shape.cast</code> method accepts enumerations where all members have const-castable expressions as their values. The shape of an enumeration is a shape with the smallest width that can represent the value of any enumeration member.</p>
<p><a href="0003-enumeration-shapes.html">RFC 3</a>: The <code>EnumMeta.__new__</code> method accepts enumerations where all members have const-castable expressions as their values. The values of members are the user-provided const-castable expressions, and not the result of casting them to a constant.</p>
<h2 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h2>
<ul>
<li>A new language-level concept makes it harder to learn the language.
<ul>
<li>Most developers already have an intuitive understanding of which expressions are const-castable.</li>
</ul>
</li>
<li><code>Const.cast</code> shadows an existing <code>Value.cast</code> method since <code>Const</code> inherits from <code>Value</code>.
<ul>
<li>No one is calling <code>Value.cast</code> through the <code>Const.cast</code> binding.</li>
<li><code>Const.cast</code> has a compatible interface (it returns a <code>Value</code>) and performs a similar function (it calls <code>Value.cast</code> first). However, it's not Liskov-compatible.</li>
</ul>
</li>
</ul>
<h2 id="rationale-and-alternatives-1"><a class="header" href="#rationale-and-alternatives-1">Rationale and alternatives</a></h2>
<p>Alternatives:</p>
<ol>
<li>Do not add this functionality. Developers will define their own const-casting functions, continue to rely on the undocumented and private <code>._as_const()</code> method, or use other workarounds.</li>
<li>Make <code>._as_const()</code> public (i.e. rename it to <code>.as_const()</code>).</li>
<li>Add a new <code>Const.cast</code> method (this option).</li>
</ol>
<p>Alternatives (2) and (3) both introduce a new language-level concept, the only difference is in the interface that is used to access it.</p>
<p>Alternative (3) fits the language better: <code>Value.cast</code> takes something value-castable and returns a <code>Value</code>, <code>Shape.cast</code> takes something shape-castable and returns a <code>Shape</code>, so <code>Const.cast</code> is a logical addition in that it takes something const-castable and returns a <code>Const</code>.</p>
<h2 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h2>
<p>Rust and C++ provide functionality (<code>const fn</code> and <code>constexpr</code> respectively) for performing computation at compile time, restricted to a strict subset of the full language. In particular, it can be used to initialize constants, which makes it similar to the functionality proposed here.</p>
<p>One challenge these languages face is the question of how large the subset should be. Rust in particular started off heavily restricting <code>const fn</code>, where it did not have any control flow. The functionality was gradually introduced later as needed.</p>
<h2 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h2>
<p>Expanding the set of const-castable expressions to include arbitrary arithmetic operations. This RFC limits it to the most requested expression, <code>Cat</code>. This simplifies implementation and reduces the likelihood of introducing bugs in the constant evaluation code, most of which would be almost never used.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-02-07</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/5">amaranth-lang/rfcs#5</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/754">amaranth-lang/amaranth#754</a></li>
</ul>
<h1 id="remove-constnormalize"><a class="header" href="#remove-constnormalize">Remove <code>Const.normalize</code></a></h1>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Remove <code>Const.normalize(value, shape)</code>.</p>
<h2 id="motivation-3"><a class="header" href="#motivation-3">Motivation</a></h2>
<p>From the name it is not clear what it is supposed to achieve (it's truncation and inversion according to the shape) and it does not check types of arguments.</p>
<p>We already have <code>Const(value, shape).value</code> and most developers should be aware of it. Having <code>Const.normalize(value, shape)</code> as well provides no benefit over the former. It's also longer.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>The <code>Const.normalize</code> method is deprecated (with the suggestion to use <code>Const().value</code>) and removed.</p>
<h2 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
</ul>
<h2 id="rationale-and-alternatives-2"><a class="header" href="#rationale-and-alternatives-2">Rationale and alternatives</a></h2>
<p>We could keep it. Removing it reduces the API surface and makes the language a bit more elegant.</p>
<h2 id="prior-art-2"><a class="header" href="#prior-art-2">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-2"><a class="header" href="#unresolved-questions-2">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-2"><a class="header" href="#future-possibilities-2">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/9">amaranth-lang/rfcs#9</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/771">amaranth-lang/amaranth#771</a></li>
</ul>
<h1 id="constant-initialization-for-shape-castable-objects"><a class="header" href="#constant-initialization-for-shape-castable-objects">Constant initialization for shape-castable objects</a></h1>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Add an extension point to shape-castable objects, for converting constant initializers (typically Python literals) to Amaranth constant expressions.</p>
<h2 id="motivation-4"><a class="header" href="#motivation-4">Motivation</a></h2>
<p><a href="0001-aggregate-data-structures.html">RFC 1</a> specifies that the <code>reset=</code> argument of a <code>View</code> accepts structured data:</p>
<pre><code class="language-python">flt_neg_reset = data.View(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<p>This structured data is internally turned into an integer constant that is supplied to <code>Signal(reset=)</code>. This mechanism is not exposed to Amaranth developers. However, this creates a clear unmet need, since at the moment there is no way to turn a layout and a field-to-value mapping into a constant integer for use elsewhere.</p>
<p>For example, if a signal is created manually and not through the <code>View</code>, this will not work despite looking reasonable (the layout is shape-castable and can be supplied to <code>Signal</code>):</p>
<pre><code class="language-python">flt_neg_reset_signal = Signal(float32_layout, reset={&quot;sign&quot;: 1})
</code></pre>
<h2 id="guide-level-explanation-2"><a class="header" href="#guide-level-explanation-2">Guide-level explanation</a></h2>
<p>Shape-castable objects must, in addition to the mandatory <code>.as_shape()</code> method, implement a mandatory <code>.const(value)</code> method to define how a constant initializer (the reset value of a <code>Signal</code> or <code>View</code>) is converted to an Amaranth constant.</p>
<p>This method is defined by shape-castable objects to convert arbitrary Python objects into Amaranth constants. For example, if a shape-castable object has complex internal structure, it can accept a dictionary with the values to be filled into various bits of this structure. If <code>Shape</code> implemented <code>ShapeCastable</code>, the method would be defined as <code>def const(self, value): return Const(value, self)</code>.</p>
<p>This method can also be directly called by the developer to construct a constant using a given shape-castable object.</p>
<h2 id="reference-level-explanation-2"><a class="header" href="#reference-level-explanation-2">Reference-level explanation</a></h2>
<p>A method <code>def const(self, obj):</code> is added on <code>ShapeCastable</code>. The class method <code>Const.cast(obj)</code> is extended to have a second argument, <code>shape=None</code>. If provided, then <code>shape</code> must be a shape-castable object. If it is an instance of <code>ShapeCastable</code>, then <code>shape.const(obj)</code> must return an Amaranth constant-castable expression with exactly the given shape. Constant casting proceeds on this expression as usual.</p>
<p>The <code>Signal(shape, reset=)</code> constructor is changed to pass <code>reset</code> through <code>Const.cast(reset, shape)</code> first.</p>
<p>The <code>.const()</code> instance method is implemented on <code>Layout</code> to accept a <code>Sequence</code> or <code>Mapping</code> instance and returns a <code>Const</code> with a bit pattern that has the fields set to the given values. Overlapping fields are written in the order of iteration of the input. If the field shape is a shape-castable object, then the value for that field is computed using <code>Const.cast(value, field.shape)</code>.</p>
<p>The <code>.const()</code> method is implemented on the metaclass of <code>Struct</code> and <code>Union</code> as <code>return self.as_shape().const(obj)</code>.</p>
<p>The <code>View(..., reset=)</code> constructor is changed to pass <code>reset</code> through to the <code>Signal()</code> constructor.</p>
<h2 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h2>
<ul>
<li>Additional method on <code>ShapeCastable</code>.
<ul>
<li>It was clear from the beginning that this functionality will likely be necessary, and we are unlikely to ever add more.</li>
</ul>
</li>
<li>The <code>reset=</code> argument becomes dependently typed.</li>
</ul>
<h2 id="rationale-and-alternatives-3"><a class="header" href="#rationale-and-alternatives-3">Rationale and alternatives</a></h2>
<p>Given:</p>
<pre><code class="language-python">class Point(Struct):
    x: 16
    y: 16
</code></pre>
<p>it is clear that there needs to be some way to go from <code>{&quot;x&quot;: 123, &quot;y&quot;: 456}</code> to <code>Cat(C(123, 16), C(456, 16))</code> without manually writing out the concatenation.</p>
<p>There are two main options for this:</p>
<ol>
<li>Implement a new method, such that <code>Point.const({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a constant of some kind (either an <code>int</code> or a <code>Const</code> or a constant-castable expression).</li>
<li>Implement an additional <code>.__init__()</code> override, such that <code>Point({&quot;x&quot;: 123, &quot;y&quot;: 456})</code> returns a view that has a constant-castable expression as its target.</li>
</ol>
<p>Option (1) has the benefit of making it clear when downstream code is creating a constant (and expects an argument where the nested data must all be constant), and of minimizing useless wrapping/unwrapping of views that would otherwise happen. It is an explicit type conversion (from a literal to <code>Const</code>).</p>
<p>Option (2) avoids introducing new names. It is an implicit type conversion (from a literal to a view, which in this case is <code>Point</code>).</p>
<p>In the end, option (1) seems preferable here since implicit type conversions are easy to unintentionally misuse. It also avoids any clashes with proposed RFC 8.</p>
<h2 id="prior-art-3"><a class="header" href="#prior-art-3">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-3"><a class="header" href="#unresolved-questions-3">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-3"><a class="header" href="#future-possibilities-3">Future possibilities</a></h2>
<p>None.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Start Date: 2023-05-11</li>
<li>RFC PR: <a href="https://github.com/amaranth-lang/rfcs/pull/10">amaranth-lang/rfcs#10</a></li>
<li>Amaranth Issue: <a href="https://github.com/amaranth-lang/amaranth/issues/770">amaranth-lang/amaranth#770</a></li>
</ul>
<h1 id="move-repl-to-valuereplicate"><a class="header" href="#move-repl-to-valuereplicate">Move <code>Repl</code> to <code>Value.replicate</code></a></h1>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Replace the standalone <code>Repl(value, count)</code> node with <code>value.replicate(count)</code>.</p>
<h2 id="motivation-5"><a class="header" href="#motivation-5">Motivation</a></h2>
<p><code>Repl</code> is a <a href="https://github.com/search?q=%2F%5CbRepl%5Cb%2F+amaranth+language%3Apython&amp;type=code">rarely used</a> construct (it's mostly useful for manual sign extension).</p>
<p>It is currently a first-class entity that has its own AST node and a name in the prelude, mostly for historical reasons (<code>Repl(v, n)</code> is analogous to Verilog's <code>{x{n}}</code>).</p>
<p><code>Repl</code> does not need to be a first-class entity; <code>Repl(x, n)</code> is almost exactly equivalent to <code>Cat(x for x in range(n))</code>. It especially does not need a name in the prelude.</p>
<h2 id="guide-level-explanation-3"><a class="header" href="#guide-level-explanation-3">Guide-level explanation</a></h2>
<p>Use of <code>Repl</code> is deprecated. To replicate a value multiple times, use <code>value.replicate()</code>.</p>
<h2 id="reference-level-explanation-3"><a class="header" href="#reference-level-explanation-3">Reference-level explanation</a></h2>
<p>Direct use of <code>Repl</code> is deprecated. Its implementation is replaced with <code>def Repl(value, count): return Value.cast(value).replicate(count)</code>.</p>
<p>A function <code>Value.replicate(count)</code> is added. It is implemented as <code>Cat(value for _ in range(count))</code>. The <code>Repl</code> AST node is removed.</p>
<h2 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h2>
<ul>
<li>Churn.</li>
<li>The proposed implementation makes <code>Value.replicate</code> valid on left-hand side of assignment, with potentially surprising behavior. However, this can be handled by prohibiting multiple assignment to the same bit of a signal in general.</li>
</ul>
<h2 id="rationale-and-alternatives-4"><a class="header" href="#rationale-and-alternatives-4">Rationale and alternatives</a></h2>
<p>Rationale:</p>
<ul>
<li>Fewer names in the prelude is always good.</li>
<li>Unlike with <code>Cat</code> (where <code>Cat()</code> makes sense), <code>Repl</code> does not make sense as a standalone node any more than <code>Part</code> does (and we do not currently export <code>Part</code>).</li>
<li>Despite existing by analogy with <code>{x{n}}</code>, it is currently turned into a concatenation before it reaches the Verilog backend <em>anyway</em>, and any future work will have to reconstruct replication from concatenation in any case.</li>
<li><code>Repl</code> being a dedicated node complicates AST processing for no reason.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Do not do this.</li>
</ul>
<h2 id="prior-art-4"><a class="header" href="#prior-art-4">Prior art</a></h2>
<p>None.</p>
<h2 id="unresolved-questions-4"><a class="header" href="#unresolved-questions-4">Unresolved questions</a></h2>
<p>None.</p>
<h2 id="future-possibilities-4"><a class="header" href="#future-possibilities-4">Future possibilities</a></h2>
<ul>
<li>The Verilog backend currently bitblasts what could be a replication. We could detect these and convert them to replications proper.</li>
<li>We could detect code like <code>Cat(x, x).eq(0b11)</code> and warn or reject it.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
